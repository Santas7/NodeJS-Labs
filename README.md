# Лабораторная работа номер 2

## Вариант 5 (16%6+1=5)

## О методах и функциях

Метод **filter()** - это встроенная функция массивов в JS/TS. Он создает новый массив, в который включаются только те элементы исходного массива, для которых переданная функция возвращает **true**.

```typescript
const newArray = array.filter(function(element) {
  // возвращаем true для элементов, которые должны быть включены в новый массив
});
```

Метод **Math.max(...array_data)** используется для нахождения максимального значения в массиве **array_data**

    1) ...array_data - оператор распыления (spread operator) преобразует элементы массива array_data в аргументы функции.
    2) Math.max() - метод объекта Math, который возвращает наибольшее из нуля или более чисел.

Метод **map()**

```typescript
return matrix.map(row => row.map(value => value ? 1 : 0));
```

**map** - метод массива, который создает новый массив, применяя функцию к каждому элементу оригинального массива. В данном случае, matrix.map создает новый массив, применяя функцию к каждой строке row исходной матрицы.

## Кортежи

Кортежи в TypeScript представляют собой упорядоченные наборы фиксированной длины, где каждый элемент кортежа может иметь свой собственный тип данных. Таким образом, кортежи могут представлять собой комбинацию различных типов данных.

Пример:

```typescript
// Объявление кортежа
let myTuple: [number, string, boolean];
myTuple = [42, "Hello", true];

// Доступ к элементам кортежа
console.log(myTuple[0]); // Вывод: 42
console.log(myTuple[1]); // Вывод: Hello
console.log(myTuple[2]); // Вывод: true

// Длина кортежа
console.log(myTuple.length); // Вывод: 3
```

В приведенном примере myTuple - это кортеж, который состоит из трех элементов: число, строка и булево значение. При объявлении кортежа нужно указывать типы элементов в квадратных скобках.

Кортежи могут быть использованы, например, когда вам нужно вернуть несколько значений из функции, и вы хотите, чтобы их типы были строго определены.

```typescript
function getPersonInfo(): [string, number] {
  return ["John Doe", 30];
}
const [name, age] = getPersonInfo();
console.log(`Name: ${name}, Age: ${age}`);
```

В этом примере функция getPersonInfo возвращает кортеж, представляющий информацию о человеке (имя и возраст), и затем с использованием деструктуризации значения кортежа присваиваются переменным name и age.

## Enum (перечисления)

Перечисления (enums) в TypeScript представляют собой именованные наборы численных значений или строковых констант. Они предоставляют удобный способ задать и использовать наборы именованных констант, что делает код более читаемым и понятным.

Пример объявления и использования перечисления:

```typescript
// Объявление перечисления
enum AminoAcid {
  Glycine = 'Глицин',
  Glutamine = 'Глутамин'
}
// Пример использования
const amino: AminoAcid = AminoAcid.Glycine;
console.log(amino); // Вывод: Глицин
```

В этом примере AminoAcid - это перечисление с двумя элементами: Glycine и Glutamine. Каждому элементу присваивается значение типа string.

Основные преимущества enum:

    1) Читаемость кода
    2) Безопасность типов (если вы пытаетесь присвоить переменной типа AminoAcid значение, не принадлежащее перечислению, TypeScript выдаст ошибку.)
    3) Автогенерация численных значений (Если значения не указаны явно, TypeScript автоматически присвоит численные значения элементам перечисления в порядке их объявления.)

## функция printPetInfo<T extends Pet>(pet: T): void:

Обобщенный тип (<T extends Pet>): Это говорит TypeScript, что функция принимает аргумент типа T, который должен быть или быть производным от типа Pet. Это позволяет использовать функцию с разными подтипами класса Pet.

Аргумент pet: Функция принимает аргумент pet, который должен быть объектом типа T (или его подтипа). Это объект, о котором мы хотим вывести информацию.

Вывод информации в консоль: Функция использует console.log для вывода информации о питомце. В этом контексте мы ожидаем, что у питомца есть свойства name, age, и label.

Доступ к свойствам объекта pet: Мы используем свойства pet.name, pet.age и pet.label для вывода соответствующей информации. Однако, как уже упоминалось в предыдущих ответах, при определении класса Pet нужно сделать свойство label необязательным (label?: string), чтобы избежать ошибок компиляции, если это свойство не существует в базовом классе Pet.

## TYPE TS

В TypeScript, ключевое слово **type** используется для создания пользовательских типов данных. Оно предоставляет возможность определить собственные именованные типы, что делает код более читаемым и поддерживаемым.

cоздание пользовательского типа

```typescript
type Point = {
    x: number;
    y: number;
};
```

Комбинирование существующих типов

```typescript
type Person = {
    name: string;
    age: number;
};

type Employee = Person & {
    jobTitle: string;
};
```

Создание альтернативных имен для существующих типов


```typescript
// Альтернативное имя для массива строк
type StringArray = Array<string>;

// Альтернативное имя для функции, принимающей два числа и возвращающей число
type MathOperation = (a: number, b: number) => number;

// Альтернативное имя для обещания, возвращающего строку
type StringPromise = Promise<string>;

// Альтернативное имя для частичного объекта Person
type PartialPerson = Partial<Person>;

// Альтернативное имя для объекта, где все свойства только для чтения
type ReadonlyPerson = Readonly<Person>;

```

StringArray - это теперь альтернативное имя для массива строк.

MathOperation - это альтернативное имя для функции, принимающей два числа и возвращающей число.

StringPromise - это альтернативное имя для обещания, возвращающего строку.

PartialPerson - это альтернативное имя для частичного объекта Person, который может содержать только некоторые из свойств Person.

ReadonlyPerson - это альтернативное имя для объекта Person, где все свойства только для чтения.


